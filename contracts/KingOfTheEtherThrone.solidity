// A contract for maintaining a throne which agents may pay to rule.
// (c) Kieran Elby. All rights reserved.
// Inspired by ethereumpyramid.com and the orignal (now-gone?) magnificent bitcoin gem.
// TODO - allow ownership transfer
// TODO - allow wizard fees to accumulate and be collected periodically
// TODO - can we use events to make interface easier?
// TODO - distinguish between kings, queens, and the caretaker wizard monarch?
// TODO - enforce time-limit on rule (can contracts do that without external action?)
// TODO - add bitcoin bridge so agents can pay in bitcoin

contract KingOfTheEtherThrone {

    struct Monarch {
        // Address from which they paid their claimFee
        // and to which their compensation will be sent.
        address etherAddress;
        // A name by which they wish to be known.
        // Encoding is assumed (but not enforced) to be printable ASCII;
        // we limit the length to 16 bytes. Can be empty.
        bytes name;
        // How much did they pay to become monarch?
        uint claimFee;
        // When did their rule start (based on block.timestamp)?
        uint coronationTimestamp;
    }

    // The hidden power behind the throne; occupies the
    // throne during gaps in succession and collects fees.
    address public wizardAddress;

    // How much must the first monarch pay?
    uint constant startingClaimFee = 10 finney;

    // The next claimFee is calculated from the previous claimFee
    // by multiplying by claimFeeAdjustNum and dividing by claimFeeAdjustDen -
    // for example, num=3 and den=2 would cause a 50% increase.
    uint constant claimFeeAdjustNum = 3;
    uint constant claimFeeAdjustDen = 2;

    // How much of each claimFee goes to the wizard (expressed as a fraction)?
    // e.g. num=1 and den=100 would deduct 1% for the wizard, leaving 99% as
    // the compensation fee for the usurped monarch.
    uint constant wizardFeeFractionNum = 1;
    uint constant wizardFeeFractionDen = 100;

    // How much ether must an agent pay now to become the monarch?
    uint public currentClaimFee;

    // The King (or Queen) of the Ether.
    Monarch public currentMonarch;

    // Earliest-first list of previous throne holders.
    Monarch[] public pastMonarchs;

    // Create a new throne, with the creator as wizard and first ruler.
    // Sets up some hopefully sensible defaults.
    function KingOfTheEtherThrone() {
        wizardAddress = msg.sender;
        currentClaimFee = startingClaimFee;
        currentMonarch = Monarch(
            wizardAddress,
            "",
            0,
            block.timestamp
        );
    }

    function getNumberOfPastMonarchs() constant returns (uint n) {
        return pastMonarchs.length;
    }

    // Fallback function - simple transactions trigger this.
    // Assume the message data is their desired name.
    function() {
        claim(msg.data);
    }

    // Claim the throne for the given name by paying the currentClaimFee.
    function claim(bytes name) {

        // If their name is too long, reject claim and refund their money.
        if (name.length > 16) {
            msg.sender.send(msg.value);
            return;
        }

        uint valuePaid = msg.value;

        // If they paid too little, reject claim and refund their money.
        if (valuePaid < currentClaimFee) {
            msg.sender.send(valuePaid);
            return;
        }

        // If they paid too much, continue with claim but refund the excess.
        if (valuePaid > currentClaimFee) {
            uint excessPaid = valuePaid - currentClaimFee;
            msg.sender.send(excessPaid);
            valuePaid = valuePaid - excessPaid;
        }

        // The claim fee payment goes to the current monarch as compensation
        // (with a commission for the wizard).
        uint wizardFee = valuePaid * wizardFeeFractionNum / wizardFeeFractionDen;
        uint compensation = valuePaid - wizardFee;

        wizardAddress.send(wizardFee);
        currentMonarch.etherAddress.send(compensation);

        // Usurp the current monarch.
        // TODO - solidarity docs a little unclear about
        // copying vs. references etc ...?
        pastMonarchs.push(currentMonarch);
        currentMonarch = Monarch(
            msg.sender,
            name,
            valuePaid,
            block.timestamp
        );

        // Increase the claim fee for next time.
        currentClaimFee = currentClaimFee * claimFeeAdjustNum / claimFeeAdjustDen;
    }

}
